<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol</title>
</head>
<body>
<script>
const a =Symbol(); //new 를 붙이지 않습니다.
const b =Symbol();

console.log("a==b", a==b);
console.log("a===b", a===b);
//a==b false
//a===b false


//Symbol :유일성 보장
const id =Symbol("id");

//유일성이 보장되므로 객체의 키로 사용한다.
//property key :심볼형


//Symbol.for() :전역 심볼
//하나의 심볼만 보장받을 수 있음
//없으면 만들고, 있으면 가져오기 때문
//Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
//Symbol.for 메소드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유

const id1=Symbol.for("id");
const id2=Symbol.for("id");
console.log("id1===id2 :", id1===id2);
//id1===id2 true

//Symbol.keyFor 는   Symbol.for의  키값을 알려줌.
Symbol.keyFor(id1); 
console.log("Symbol.keyFor(id1) :", Symbol.keyFor(id1));
//Symbol.keyFor(id1) : id




//Symbol 은   description 으로 이름을 알수 있다.
const id3 =Symbol("id 입니다.");
id3.description; 
console.log("id3.description:", id3.description);
//id3.description: id 입니다.



//** 숨겨진 Symbole key 보는 법
const id7 =Symbol('id7');
const user={
    name:"Mike",
    age:30,
    [id7]:'myid'
}
//숨겨진 심볼 key 만 출력
Object.getOwnPropertySymbols(user);
console.log("Object.getOwnPropertySymbols(user):", Object.getOwnPropertySymbols(user));
//Object.getOwnPropertySymbols(user): [Symbol(id7)]

//전체 출력
Reflect.ownKeys(user);
console.log("Reflect.ownKeys(user):", Reflect.ownKeys(user));
//Reflect.ownKeys(user): (3) ['name', 'age', Symbol(id7)]


</script>    
</body>
</html>